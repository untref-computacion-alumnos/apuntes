# Primer Parcial - Primer Cuatrimestre - 2025

## Ejercicio 1

Implementar un nuevo método de la _lista circular_ que reciba como parámetro `k`, un entero mayor o igual que cero y que mueva la cabeza de la lista _k % size_ posiciones, donde `size` es el tamaño actual de la lista.

```go
func (l *CircularList[T]) Rotate(k int) { ... }
```

## Ejercicio 2

Implementar un _Tipo Abstracto de Datos_ (_TAD_) llamado `Round` que represente una ronda de personas. El _TAD_ deberá ser capaz de almacenar objetos de tipo `Person`. Una ronda de personas se caracteriza porque cada integrante de la ronda tiene un sucesor y antecesor. Se debe llevar la cuenta de cuantas personas hay.

```go
import "fmt"

type Person struct {
  name      string
  lastName  string
}

func NewPerson(name, lastName string) Person {
  return Person{ name: name, lastName: lastName}
}

func (p *Person) String() string {
  return fmt.Println("%s %s", p.name, p.lastName)
}

func (p *Person) Equal(other Person) bool {
  return p.name == other.name && p.lastName == other.lastName
}

type Round struct {
  list *CircularList[Person]
}
```

Implemente la ronda Round que deberá almacenar las personas utilizando una _lista circular_. Cada nodo de la lista deberá contener una persona Person.

- `NewRound() Round`: Crea una nueva ronda vacía. Esta función deberá retornar un puntero a la nueva ronda.
- `AddPerson(name, lastName string)`: Un método que agrega a una persona en la ronda, la debe agregar al final de todos los participantes. Una misma persona no puede estar más de una vez en la ronda.
- `Rotate(k int)`: Puede recibir enteros positivos y negativos. Si el número es positivo avanza la cabeza de la lista subyacente la cantidad de lugares indicados y si es negativo retroceder la cabeza de la lista.
- `Remove(k int)`: Elimina a la persona que se encuentra en la posición `k` indicada.
- `NumberOfPersons() int`: Retorna la cantidad de personas que hay en la ronda.

Indica el orden de cada operación.

**Nota**: La ronda `Round` y la _lista circular_ no están en el mismo package.

## Ejercicio 3

Dada un _hashtable_ cerrado de tamaño 7, mostrar paso a paso las siguientes operaciones:

- `Insert(0)`
- `Insert(7)`
- `Insert(21)`
- `Insert(2)`
- `Insert(30)`
- `Insert(7)`
- `Insert(21)`
- `Insert(2)`
- `Insert(28)`

La función de hash usada es _h(x) = x mod 7_.

## Ejercicio 4

Dado un arreglo de enteros que originalmente se encontraba ordenado pero fue rotado una cantidad desconocida de veces, se pide escribir una función que utilice la técnica de _División y Conquista_ para encontrar la posición del menor elemento del arreglo. Calcular el orden aplicando el _Teorema del Maestro_.

```md
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] -> [7, 8, 9, 0, 1, 2, 3, 4, 5, 6] -> Debe devolver 3
```

**Nota**: Funciones que se permiten usar para el parcial:

```go
type CircularList[T comparable] struct {
  head  *DoublyLinkedNode[T]
  size  int
}

func NewCircularList[T comparable]() *CircularList[T] { ... }

func (l *CircularList[T]) Head() *DoublyLinkedNode[T] { ... }

func (l *CircularList[T]) Tail() *DoublyLinkedNode[T] { ... }

func (l *CircularList[T]) Size() int { ... }

func (l *CircularList[T]) Append(data T) *DoublyLinkedNode[T] { ... }

func (l *CircularList[T]) Remove(data T) { ... }
```
