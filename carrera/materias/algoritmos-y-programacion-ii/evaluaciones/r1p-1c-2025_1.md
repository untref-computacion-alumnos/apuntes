# Recuperatorio Primer Parcial - Primer Cuatrimestre - 2025

## Ejercicio 1

Implementar un tipo genérico `Bag[T any` que permita almacenar múltiples elementos, incluso repetidos. La implementación debe usar internamente una _lista circular doblemente enlazada_.

- Se deben implementar los siguientes métodos, de la manera más eficientemente posible:

  ```go
  type Bag[T comparable] struct {
    // Implementar.
  }

  // Add agrega un elemento a la bolsa.
  func (b *Bag[T]) Add(elem T) { ... }

  // Count retorna la cantidad de apariciones de un elemento en la bolsa.
  func (b *Bag[T]) Count(elem T) int { ... }

  // Remove elimina una y solo una ocurrencia del elemento si existe, y retorna true o false.
  func (b *Bag[T]) Remove(elem T) bool { ... }

  // Len retorna la cantidad total de elementos incluyendo duplicados.
  func (b *Bag[T]) Len() int { ... }
  ```

  ```go
  // CircularList está definida a continuación y no tiene ningún método implementado.
  // Está todo en el mismo package.

  // CircularList es una lista circular genérica.
  type CircularList[T comparable] struct {
    head  *DoublyLinkedNode[T]
    size  int
  }

  type DoublyLinkedNode[T comparable] struct {
    Data  T
    Next  *DoublyLinkedNode[T]
    Prev  *DoublylinkedNode[T]
  }
  ```

- Justificar el orden de cada una de las operaciones.

## Ejercicio 2

Se tiene un _diccionario_ (_map_) en _Go_ del tipo `map[string]MateriaNota`, donde:

```go
type MateriaNota struct {
  Materia string
  Nota    int
}
```

Se pide escribir una función en _Go_ que reciba ese diccionario y devuelva un nuevo `map[string][]string` donde:

- La clave es nombre de la materia.
- El valor es un _slice_ con los nombres de los alumnos que aprobaron esa materia (nota >= 4).

## Ejercicio 3

Implementar una función recursiva en _Go_ que, dado un número entero positivo, devuelva cuántos dígitos pares contiene.

```go
ContarPares(2486)   // -> 4
ContarPares(1357)   // -> 0
ContarPares(0)      // -> 1
ContarPares(12345)  // -> 2
```

## Ejercicio 4

Un problema puede resolverse de dos maneras distintas:

- **Método A**: Una solución iterativa, que tiene un costo _O(n log n)_.
- **Método B**: Una solución por división y conquista, que divide el problema en 2 subproblemas de tamaño _n / 2_, resuelve cada subproblema de forma recursiva. El costo de partir el problema en dos partes iguales es de _O(n)_ y luego combina las soluciones parciales en tiempo _O(n²)_.

1. Expresar el tiempo de ejecución del _Método B_ de la forma: _T(n) = aT(bn) + f(n)_
2. ¿Cuál método es **más eficiente asintóticamente**? Justificar formalmente usando el _Teorema del Maestro_.
3. ¿Qué pasaría si la combinación de los resultados en el _Método B_ tuviera un costo de _O(n)_ en lugar de _O(n²)_? ¿Cuál método sería preferible?
