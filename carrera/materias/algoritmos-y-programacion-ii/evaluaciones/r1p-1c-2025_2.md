# Recuperatorio Primer Parcial - Primer Cuatrimestre - 2025

## Ejercicio 1

Definir el tipo `DoublyQueue[t any]` sobre una _lista doblemente enlazada_. `DoublyQueue` es una _cola doble_ que permite encolar y desencolar por ambos extremos de la lista.

La lista está definida en el mismo paquete y no tiene ningún método, por lo tanto se puede manipular directamente.

```go
type DoublyLinkedList[T any] struct {
  head  *Node[T]
  tail  *Node[T]
  size  int
}

type Node[T any] struct {
  value T
  prev  *Node[T]
  nexr  *Node[T]
}
```

Implementar los siguientes métodos de `DoublyQueue`:

```go
// EnqueueFront encola en la cabeza de la lista.
func (d *DoublyQueue[T]) EnqueueFront(value T) { ... }

// EnqueueBack encola en la cola de la lista.
func (d *DoublyQueue[T]) EnqueueBack(value T) { ... }

// PopFront desencola de la cabeza de la lista.
func (d *DoublyQueue[T]) PopFront() (T, error) { ... }

// PopBack desencola de la cola de la lista
func (d *DoublyQueue[T]) PopBack() (T, error) { ... }

// IsEmpty retorna true si DoublyQueue está vacía.
func (d *DoublyQueue[T]) IsEmpty() bool { ... }
```

## Ejercicio 2

Implementar la función `func NewDoublyQueue[T any]() *DoublyQueue[T] { ... }` que devuelva una _cola doble_ como la del ejemplo anterior y escribir una función `IsPalindrome` en un `package main`, que usa la _cola doble_ y determine si una cadena de caracteres que recibe como parámetro es un palíndromo (se puede leer igual de adelante hacia atrás y viceversa).

Por ejemplo:

```md
rotor
neuquen
```

Calcular y justificar el orden de la función `IsPalindrome`.

## Ejercicio 3

Implementar un _TAD_ `Queue` pero que internamente use dos _pilas_. La `Queue` debe tener métodos para encolar, desencolar y verificar si está vacía. La operación `Enqueue` debe ser _O(1)_. `Dequeue` debe ser _O(n)_.

## Ejercicio 4

Implementar la función `BinarySearch(arr []int, x int) int` en forma recursiva que recibe un arreglo de enteros ordenado y un entero `x` a buscar y retorna la posición dentro del arreglo donde se encuentra `x` o `-1` si no está. Calcular y justificar el orden de la función.
