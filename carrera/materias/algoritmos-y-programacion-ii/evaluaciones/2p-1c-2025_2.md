# Segundo Parcial - Primer Cuatrimestre - 2025

## Ejercicio 1

Dado un _árbol binario de búsqueda_, con el siguiente recorrido en _preorder_:

```md
R -> H -> D -> B -> F -> E -> K -> Y -> T -> P -> O -> Q -> Z
```

Se pide:

1. Dibujar el árbol (**Pista**: Escribir el recorrido _inorder_ puede servir de ayuda).
2. Eliminar la raíz, reemplazándola por su sucesor. Graficar.
3. Insertar las letras V, W y X en ese orden. Graficar.
4. ¿El _árbol_ resultante es _AVL_? Justificar la respuesta. Si no fuera _AVL_, indicar el/los nodos que no están balanceados.

## Ejercicio 2

Supongamos que estamos diseñando un sistema para gestionar tareas, donde cada tarea puede ser una tarea simple o una tarea compuesta por otras subtareas, que a su vez pueden ser simples o compuestas. Todas las tareas tienen un tiempo y un costo asociado. En el caso de las tareas simples el tiempo se mide en segundos y corresponde a la duración de la misma y en el caso de las compuestas el tiempo es el mayor de sus subtareas, ya que todas se ejecutan en paralelo. Análogamente el costo de una tarea simple está expresao en pesos y el costo de las tareas compuestas es la suma de los costos de sus subtareas. Se pide:

1. Modelar en _Go_, aplicando el patrón de diseño que corresponda, teniendo en cuenta que todas las tareas deben responder a los métodos `GetTime()` y `GetCost()`, que devuelven su tiempo de ejecución y costo respectivamente.
2. Escribir la función `GetTime()` tanto para las tareas simples como compuestas.
3. Escribir la función `GetCost()` tanto para las tareas simples como compuestas.

## Ejercicio 3

Escribir una función en _Go_ que reciba como parámetro un arreglo de enteros que representan denominaciones de monedas, ordenadas de mayor a menor y un monto M. La función debe devolver un diccionario indicando cuántas monedas de cada denominación se deben entregar para completar el monto M, teniendo en cuenta que se deben entregar la menor cantidad posibles de monedas.

Por ejemplo:

```go
cambio := Cambio(100, 50, 20, 10, , 5, 2, 1) // cambio == {50:1, 20:1, 10:1, 5:1, 2:2}
```

## Ejercicio 4

Dado el siguiente arreglo de enteros `10, 7, 10, 5, -2, 5, 11, 8` ordenar de mayor a menor aplicando el algoritmo de _MergeSort_ mostrando paso a paso la aplicación del algoritmo. Indicar el orden del algoritmo y si el mismo es estable e in-situ. Justificar.
