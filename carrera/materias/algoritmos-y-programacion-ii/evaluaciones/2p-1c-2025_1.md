# Segundo Parcial - Primer Cuatrimestre - 2025

## Ejercicio 1

Dado un _montículo binario de mínimos_ inicialmente vacío:

1. Insertar los siguientes elementos en el orden dado: S, J, F, M, X, U, D, C, P, A.
2. Eliminar el mínimo 2 veces.
3. Indicar para qué se usa la operación `upHeap` y programarla en _Go_ considerando que se usa un arreglo de enteros como contenedor de datos. (Programar para un arreglo de enteros y no de string).

## Ejercicio 2

Se desea recorrer una estructura de datos que representa una Colección de Files organizados por etiquetas. Cada File puede estar etiquetado con una o más categorías (por ejemplo: "fotos", "trabajo", "2023").

`File` tiene la siguiente estructura:

```go
type File struct {
  name  string
  label []string
}

type Colection []File
```

- Implementar un método de `File` `HasLabel` que reciba una etiqueta y devuelva _true_ si ese `File` tiene esa etiqueta o _false_ en caso contrario.
- Programar un iterador que cumpla con la siguiente interfaz. El iterador debe recorrer solo los elementos de la colección que tienen una etiqueta dada.

  ```go
  type Iterator interface {
    HasNext() bool  // Retorna true si hay más elementos en la colección.
    Next() File     // Retorna el próximo elemento de la colección que tiene la etiqueta correspondiente.
  }
  ```

- Agregar un método de `Colection` llamado `FilterLabel` que reciba como parámetro una etiqueta y devuelva el iterador correspondiente.

  Ejemplo:

  ```go
  func main() {
    colection := Colection {
      { "vacaciones.jpg", []string{ "fotos", "2023" } },
      { "reporte.docx", []string{ "trabajo", "2023" } },
      { "familia.png", []string{ "fotos" } },
      { "plan.xlsx", []string{ "trabajo" } },
    }
    fmt.Println("Archivos con etiqueta 'fotos':")
    iterator := colection.FilterLabel("fotos")
    for iterator.HasNext() {
      file := iterator.Next()
      fmt.Println(" -", file.name)
    }
  }
  ```

  Debe mostrar:

  ```go
  " -vacaciones.jpg"
  " -familia.png"
  ```

## Ejercicio 3

Dadas las subcadenas _s1_: "A, G, A, A, C, T, X, C, T, X" y _s2_: "A, A, C, T, C, X, A, T, X, C", calcular la subsecuencia común más larga (LCS) aplicando programación dinámica. Mostrar los cálculos realizados e indicar cual es esa cadena. Indicar la ecuación de recurrencia usada para completar la tabla.

## Ejercicio 4

Dado el siguiente arreglo `[ABC, EFD, AAA, CDA, XAZ, ABC, DJX]` ordenar de forma ascendente aplicando el algoritmo de _RadixSort_ (LSD). Indicar el orden del algoritmo y si el mismo es estable. Justificar.
