# Recuperatorio Segundo Parcial - Primer Cuatrimestre - 2025

## Ejercicio 1

Dada la implementación de un _ABB_:

```go
import "cmp"

type BinaryNode[T cmp.Ordered] struct {
  left  *BinaryNode[T]
  right *BinaryNode[T]
  data  T
}

func NewBinaryNode[T cmp.Ordered](data T, left, right *BinaryNode[T]) *BinaryNode[T] {
  return &BinaryNode[T]{ left: left, right: right, data: data }
}

func (bn *BinaryNode[T]) GetData() T {
  return bn.data
}

func (bn *BinaryNode[T]) GetLeft() *BinaryNode[T] {
  return bn.left
}

func (bn *BinaryNode[T]) GetRight() *BinaryNode[T] {
  return bn.right
}
```

```go
type BinarySearchTree[T cmp.Ordered] struct {
  root  *BinaryNode[T]
}

func NewBinarySearchTree[T cmp.Ordered]() *BinarySearchTree[T] {
  return &BinarySearchTree[T]{ root: nil }
}

func (bst *BinarySearchTree[T]) GetRoot() *BinaryNode[T] {
  return bst.root
}

func (bst *BinarySearchTree[T]) String() string {
  return bst.InOrder()
}

func (bst *BinarySearchTree[T]) Insert(k int) {
  bst.root = bst.insertByNode(bst.root, k)
}

func (bst *BinarySearchTree[T]) Remove(k int) {
  bst.root = bst.removeByNode(bst.root, k)
}

func (bst *BinarySearchTree[T]) Size() int {
  return size(bst.root)
}

func (bst *BinarySearchTree[T]) IsEmpty() bool {
  return bst.Size() == 0
}

func (bst *BinarySearchTree[T]) Clear() {
  bst.root = nil
}
```

Se pide:

1. Completar los siguientes métodos de `BinaryNode`:

   ```go
   func (bn *BinaryNode[T]) Height() int { ... }

   func (bn *BinaryNode[T]) Size() int { ... }
   ```

2. Completar los siguientes métodos de `BinarySearchTree`:

   ```go
   func (bst *BinarySearchTree[T]) FindMin() (T, error) { ... }

   func (bst *BinarySearchTree[T]) FindMax() (T, error) { ... }
   ```

Justificar el orden de las operaciones.

## Ejercicio 2

Plan de actividades: Se tiene un conjunto de actividades _a_<sub>_i_</sub>, que se pueden realizar en un tiempo determinado. Cada actividad tiene un tiempo de inicio _s_<sub>_i_</sub>, y un tiempo de finalización _f_<sub>_i_</sub>. Se desea seleccionar la mayor cantidad de actividades que no se superpongan. Dos actividades _a_<sub>_i_</sub>, _a_<sub>_j_</sub> son compatibles si los intervalos _[s<sub>i</sub>, f<sub>i</sub>)_ y _[s<sub>j</sub>, f<sub>j</sub>)_ no se superponen.

1. Indicar cuál es el paso greedy para resolver el problema usando la técnica de algoritmos greedy.
2. Implementar en _Go_ una solución recursiva. Justificar el orden.

## Ejercicio 3

Dada la siguiente _lista doblemente enlazada con centinelas_:

```go
type Node[T comparable] struct {
  data  T
  next  *Node[T]
  prev  *Node[T]
}

func NewNode[T comparable](dato T) *Node[T] { ... }

func (n *Node[T]) Data() T { ... }

func (n *Node[T]) Next() *Node[T] { ... }

func (n *Node[T]) Prev() *Node[T] { ... }

func (n *Node[T]) SetData(dato T) { ... }

func (n *Node[T]) SetNext(sig *Node[T]) { ... }

func (n *Node[T]) SetPrev(prev *Node[T]) { ... }

func (n *Node[T]) InsertAfter(dato T) { ... }

func (n *Node[T]) InsertBefore(dato T) { ... }

func (n *Node[T]) Remove() { ... }

func (n *Node[T]) RemoveNext() { ... }

func (n *Node[T]) RemovePrev() { ... }
```

```go
type List[T comparable] struct {
  head  *Node[T]
  tail  *Node[T]
  size  int
}

func NewList[T comparable]() *List[T] { ... }

func (l *List[T]) Append(dato T) { ... }

func (l *List[T]) Prepend(dato T) { ... }

func (l *List[T]) RemoveFirst() { ... }

func (l *List[T]) RemoveLast() { ... }

func (l *List[T]) Remove(dato T) { ... }

func (l *List[T]) IsEmpty() bool { ... }

func (l *List[T]) Size() int { ... }

func (l *List[T]) Head() *Node[T] { ... }

func (l *List[T]) Tail() *Node[T] { ... }

func (l *List[T]) Find(dato T) *Node[T] { ... }

func (l *List[T]) Clear() { ... }
```

Se pide implementar un _iterador_ que cumpla con la siguiente interfaz:

```go
type DoubleIterator[T comparable] interface {
  HasNext() bool
  Next() (T, error)
  HasPrevious() bool
  Previous() (T, error)
}
```

1. Implementar el tipo `ListIterator` que cumpla con la interfaz `DoubleIterator`.
2. Implementar el método `NewIterator` en `List` que devuelva un iterador.

## Ejercicio 4

_HeapSort_:

1. ¿Para ordenar un arreglo de mayor a menor se debe construir un _heap de mínimos_ o un _heap de máximos_? Justificar.
2. Mostrar paso a paso como funciona _HeapSort_ para ordenar los siguientes números enteros de mayor a menor: `10, -1, 3, -1, 4, -1, 3, 2, -1`. Justificar el orden del algoritmo.
3. _¿HeapSort_ es estable e in-place? Justificar.
